// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc293.DeepestSpace.subsystems;



import edu.wpi.first.wpilibj.command.Subsystem;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;



/**
 *
 */
public class Climber extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX frontClimber;
    private WPI_TalonSRX backClimber;
    private Spark climberDriver;
    private WPI_TalonSRX frontCimberFollow;
    private DigitalOutput redOutput;
    private DigitalOutput greenOutput;
    private DigitalOutput blueOutput;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private double fkP = 4.0;
    private double fkI = -0;
    private double fkD = -0;

    private double bkP = 16.0;
    private double bkI = -0;
    private double bkD = -0;

    private double backSetpoint = 0;
    private double frontSetpoint = 0;
    private double manualSpeed = 60; //Raw Sensor 
    private double pidSpeed = 60;

    public double climbTarget = 0;

    // For Future   Reference
    private double hab2Height = 6; //In inches
    private double hab3Height  = 19;

    private double heightLimit = 10; // In raw sensor units

    public Climber() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        frontClimber = new WPI_TalonSRX(15);
        
        
        
        backClimber = new WPI_TalonSRX(16);
        
        
        
        climberDriver = new Spark(0);
        addChild("climberDriver",climberDriver);
        climberDriver.setInverted(false);
        
        frontCimberFollow = new WPI_TalonSRX(17);
        
        
        
        redOutput = new DigitalOutput(0);
        addChild("RedOutput",redOutput);
        
        
        greenOutput = new DigitalOutput(1);
        addChild("GreenOutput",greenOutput);
        
        
        blueOutput = new DigitalOutput(2);
        addChild("BlueOutput",blueOutput);
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


        frontClimber.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative,0,4000);
        frontClimber.config_kP(0, fkP);
        frontClimber.config_kI(0, fkI);
        frontClimber.config_kD(0, fkD);
        frontClimber.setSelectedSensorPosition(0);
        frontClimber.setNeutralMode(NeutralMode.Brake);
        //frontClimber.configForwardSoftLimitEnable(true);
        //frontClimber.configForwardSoftLimitThreshold(inchesToRaw(heightLimit));

        backClimber.setSensorPhase(false);
        backClimber.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative,0,4000);
        backClimber.config_kP(0, bkP);
        backClimber.config_kI(0, bkI);
        backClimber.config_kD(0, bkD);
        backClimber.setSelectedSensorPosition(0);
        backClimber.setNeutralMode(NeutralMode.Brake);
        //backClimber.configForwardSoftLimitEnable(true);
        //backClimber.configForwardSoftLimitThreshold(inchesToRaw(heightLimit));

        frontCimberFollow.follow(frontClimber);
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

        backClimber.setSelectedSensorPosition((int) backSetpoint);
        frontClimber.setSelectedSensorPosition((int) frontSetpoint);


        if (climbTarget != 0.0){
            if(climbAtPosition(climbTarget)){
                greenOutput.set(true);
            }
            else{
                greenOutput.set(false);
            }
        }
        else{
            greenOutput.set(false);
        }
        
    }
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.\
    public void setBackPosInches(double inches){
        backSetpoint = ((inches * 4096) / (2 * 3.14));
    }
    
    public int inchesToRaw(double inches){
        return (int)((inches * 4096) / (2 * 3.14));
    }

    public double rawToInches(int rawEncoderUnits){
        return ((((double)(rawEncoderUnits)) * (1/6.28))/4096);
    }

    public int getBackClimbEnc(){
        return backClimber.getSensorCollection().getQuadraturePosition();
    }

    public int getFrontClimbEnc(){
        return frontClimber.getSensorCollection().getQuadraturePosition();
    }

    public void backClimberUp(){
        backSetpoint += manualSpeed;
    }
    
    public void backClimberDown(){
        backSetpoint -= manualSpeed;
    }

    public void setFrontPosInches(double inches){
        frontSetpoint = ((inches * 4096) / (2 * 3.14));
    }

    public void frontClimberUp(){
        frontSetpoint += manualSpeed;
    }
    
    public void frontClimberDown(){
        frontSetpoint -= manualSpeed;
    }

    public void pidFrontUp(){
        frontSetpoint += pidSpeed;
    }

    public void pidFrontDown(){
        frontSetpoint -= pidSpeed;
    }

    public void pidBackUp(){
        backSetpoint += pidSpeed;
    }
    public void pidBackDown(){
        backSetpoint -= pidSpeed;
    }

    public void landingForward(){
        climberDriver.set(0.5);
    }

    public void landingBackward(){
        climberDriver.set(-0.5);
    }

    public void landingStop(){
        climberDriver.set(0);
    }

    public boolean climbAtPosition(double position){
        int frontDif = Math.abs(inchesToRaw(position) - getFrontClimbEnc());
        int backDif = Math.abs(inchesToRaw(position) - getBackClimbEnc());
        double toler = 0.25;

        if(frontDif > inchesToRaw(position - toler) && frontDif < inchesToRaw(position + toler)){

            if(backDif > inchesToRaw(position - toler) && backDif < inchesToRaw(position + toler)){

                return true;

            }
            else{
                return false;
            }
        }

        else{
            return false;
        }
    }
}

